on:
  schedule:
    - cron: "30 0 * * *"
  workflow_dispatch:
  push:

jobs:
  check:
    name: Check Version
    runs-on: ubuntu-latest
    
    outputs:
      versionINDI: ${{ steps.fetch_tags.outputs.indi }}
      versionINDI3rdPARTY: ${{ steps.fetch_tags.outputs.indi-3rdparty }}
      versionKStars: ${{ steps.fetch_tags.outputs.kstars }}
      needs_update: ${{ steps.fetch_tags.outputs.needs_update }}
    steps:
      - name: Restore
        id: load_cache_release
        uses: actions/cache@v4
        with:
          path: latest_releases.json
          key: release-tags-${{ github.run_id }}
          restore-keys: release-tags-
      - name: Fetch latest tags
        id: fetch_tags
        run: |
          REPOS=("indilib/indi" "indilib/indi-3rdparty")
          echo "repos=${REPOS[*]}" >> $GITHUB_ENV
          
          echo "{" > new_releases.json
          NEEDS_UPDATE=false
          RAN=false
          for repo in ${REPOS[*]}; do
            if [ "$RAN" = "true" ]; then
              echo "," >> new_releases.json
            fi
            #RAN=true
            LATEST_TAG=$(curl -s https://api.github.com/repos/$repo/releases/latest | jq -r .tag_name)
            PREVIOUS_TAG=$(jq -r --arg rep "$repo" '.[$rep] // ""' latest_releases.json)
            echo "${repo#*/}=$LATEST_TAG" >> $GITHUB_OUTPUT
            echo "Previous release for $repo(${repo#*/}): $PREVIOUS_TAG"
            if [ "$LATEST_TAG" != "$PREVIOUS_TAG" ]; then
              echo "New release detected for $repo: $LATEST_TAG"
              NEEDS_UPDATE=true
            fi
            echo  "    \"$repo\": \"$LATEST_TAG\"," >> new_releases.json
          done
          LATEST_TAG=$(git ls-remote -h https://invent.kde.org/kde/kstars.git | grep '\/stable-*' | tail -n1 | sed 's/\// /g' | awk '{print $4}')
          PREVIOUS_TAG=$(jq -r --arg rep "kstars" '.[$rep] // ""' latest_releases.json)
          echo -n "    \"kstars\": \"$LATEST_TAG\"" >> new_releases.json          
          echo "}" >> new_releases.json

          if [ "$LATEST_TAG" != "$PREVIOUS_TAG" ]; then
              echo "New release detected for kstars: $LATEST_TAG"
              NEEDS_UPDATE=true
          fi
          echo "kstars=$LATEST_TAG" >> $GITHUB_OUTPUT
          
          echo "needs_update=$NEEDS_UPDATE" >> $GITHUB_OUTPUT
          if [ "$NEEDS_UPDATE" = "true" ]; then
            mv new_releases.json latest_releases.json            
          fi



  dothings:
    name: Print the result from check
    runs-on: ubuntu-latest
    needs: check
    steps:
      - name: Pi Image
        id: latestImage
        run: | 
          LATEST_VERSION=$(curl -s https://downloads.raspberrypi.com/raspios_arm64/images/ | grep -oP '(?<=href=")[^"]+(?=")' | sort | tail -n 1)
          echo "LATEST_VERSION=${LATEST_VERSION}" >> $GITHUB_ENV
          echo "Cache Key: raspios-${LATEST_VERSION}"
      - name: Restore
        id: cache-restore 
        uses: actions/cache/restore@v4 
        with: 
          path: raspios_arm64-latest.img.xz 
          key: raspios-${{ env.LATEST_VERSION }} 
          restore-keys: raspios- 
      - name: DownloadImage
        if: steps.cache-restore.outputs.cache-hit != 'true' 
        run: | 
          LATEST_DIR="https://downloads.raspberrypi.com/raspios_arm64/images/${LATEST_VERSION}"
          LATEST_FILE=$(curl -s "$LATEST_DIR" | grep -oP '(?<=href=")[^"]+\.img\.xz(?=)' | head -n 1)
          DOWNLOAD_URL=${LATEST_DIR}${LATEST_FILE}
          wget -O raspios_arm64-latest.img.xz "$DOWNLOAD_URL" 
      - name: Save to Cache 
        if: steps.cache-restore.outputs.cache-hit != 'true' 
        uses: actions/cache/save@v4 
          with:
            path: raspios_arm64-latest.img.xz
            key: raspios-${{env.LATEST_VERSION }} 
      - name: do stuff
        if: needs.check.outputs.needs_update == 'true'
        run: |
          echo "UPDATE"
      - run: |
          echo '${{ needs.check.outputs.versionINDI }}'
          echo '${{ needs.check.outputs.versionINDI3rdPARTY }}'
          echo '${{ needs.check.outputs.versionKStars }}'
