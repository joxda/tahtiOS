on:
  schedule:
    - cron: "30 0 * * *"
  workflow_dispatch:
  push:

jobs:
  check:
    name: Check Version
    runs-on: ubuntu-latest
    
    outputs:
      versionINDI: ${{ steps.fetch_tag.outputs.indi }}
      versionINDI3rdPARTY: ${{ steps.fetch_tags.outputs.indi-3rdparty }}
      
    steps:
      - name: Restore
        id: cache_release
        uses: actions/cache@v3
        with:
          path: latest_releases.json
          key: release-tags
          restore-keys: release-tags
      - name: Fetch latest tags
        id: fetch_tags
        run: |
          REPOS=("indilib/indi" "indilib/indi-3rdparty")
          echo "repos=${REPOS[*]}" >> $GITHUB_ENV
          if [ ! -f last_releases.json ]; then
            echo "{}" > last_releases.json
          fi
          
          echo "{" > new_releases.json
          NEEDS_UPDATE=false
          for repo in $repos; do
            LATEST_TAG=$(curl -s https://api.github.com/repos/$repo/releases/latest | jq -r .tag_name)
            PREVIOUS_TAG=$(jq -r --arg repo "$repo" '.[$repo] // empty' last_releases.json)
            echo "${repo#*/}=$LATEST_TAG" >> $GITHUB_OUTPUT
            echo "Previous release for $repo: $PREVIOUS_TAG"
            if [ "$LATEST_TAG" != "$PREVIOUS_TAG" ]; then
              echo "New release detected for $repo"
              NEEDS_UPDATE=true
            fi
            echo "\"$repo\": \"$LATEST_TAG\"," >> new_releases.json
          done
          
          echo "}" >> new_releases.json
          
          echo "needs_update=$NEEDS_UPDATE" >> GITHUB_ENV
          if [ $NEEDS_UPDATE ]; then
            echo "Caching..."
            mv new_releases.json latest_releases.json
          fi

      - name: do stuff
        if: env.needs_update == 'true'
        run: |
          echo "UPDATE"

  print:
    name: Print the result from check
    runs-on: ubuntu-latest
    needs: check
    steps:
      - run: |
          echo '${{ needs.check.outputs.versionINDI }}'
          echo '${{ needs.check.outputs.versionINDI3rdPARTY }}'
